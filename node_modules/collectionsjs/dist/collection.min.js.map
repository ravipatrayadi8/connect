{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///collection.min.js","webpack:///webpack/bootstrap 93e2d95ecb3671964260","webpack:///./src/collection.js"],"names":["root","factory","exports","module","define","amd","Collection","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","items","arguments","undefined","item","push","property","sum","count","size","slice","collection","concat","all","closure","first","callback","forEach","filter","indexOf","_ref","deep","flattened","apply","contains","flatten","index","find","seperator","join","keys","last","map","add","initial","reduce","splice","reverse","start","end","compare","sort","order","isAscending","toLowerCase","a","b","JSON","stringify","previous","current","take","_this","unique","_ret","mappedCollection","v","mappedItem","has","_this2","array","get","collectable","name","Error","_len","args","_key"],"mappings":"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","file":"collection.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Collection\"] = factory();\n\telse\n\t\troot[\"Collection\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Collection\"] = factory();\n\telse\n\t\troot[\"Collection\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * The Collection object.\n\t *\n\t * @example\n\t * let collection = new Collection([1, 2, 3]);\n\t */\n\t\n\tvar Collection = function () {\n\t    /**\n\t     * The collection constructor.\n\t     *\n\t     * @param  {Array} [items=[]] the array to collect.\n\t     * @return {Collection} A Collection object.\n\t     */\n\t\n\t    function Collection() {\n\t        var items = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\n\t        _classCallCheck(this, Collection);\n\t\n\t        /**\n\t         * The internal array.\n\t         * @type {Array|Object}\n\t         */\n\t        this.items = items;\n\t    }\n\t\n\t    /**\n\t     * Adds an item to the collection.\n\t     *\n\t     * @param {*} item the item to be added.\n\t     * @return {Collection} the collection object.\n\t     * @example\n\t     * const collection = new Collection();\n\t     * collection.add('Arya');\n\t     * console.log(collection.first()); //outputs 'Arya'\n\t     */\n\t\n\t\n\t    _createClass(Collection, [{\n\t        key: 'add',\n\t        value: function add(item) {\n\t            this.items.push(item);\n\t\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Gets the collected elements in an array.\n\t         *\n\t         * @return {Array} the internal array.\n\t         * @example\n\t         * const collection = new Collection([1, 2, 3]);\n\t         * console.log(collection.all()); // [1, 2, 3]\n\t         */\n\t\n\t    }, {\n\t        key: 'all',\n\t        value: function all() {\n\t            return this.items;\n\t        }\n\t\n\t        /**\n\t         * Gets the average value of the array or a property or a callback return value.\n\t         * If no property is provided: it will calculate the average value of the array (Numeric array).\n\t         * If property is a string: it will calculate the average value of that property for all\n\t         *  objects in the array.\n\t         * If Property is a callback: the the averaging will use the value returned instead.\n\t         *\n\t         * @param  {function|string} [property=null] The property name or the callback function.\n\t         * defaults to null.\n\t         * @return {number} The average value.\n\t         * @example <caption>Averaging elements</caption>\n\t         * const collection = new Collection([1, 2, 3]);\n\t         * console.log(collection.average()); // 2\n\t         * @example <caption>Averaging a property</caption>\n\t         * const collection = new Collection([\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]);\n\t         * console.log(collection.average('age')); // 10\n\t         * @example <caption>Averaging using a callback</caption>\n\t         * const collection = new Collection([\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]);\n\t         * console.log(collection.average(i => i.age)); // 10\n\t         */\n\t\n\t    }, {\n\t        key: 'average',\n\t        value: function average() {\n\t            var property = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];\n\t\n\t            return this.sum(property) / this.count();\n\t        }\n\t\n\t        /**\n\t         * Chunks the collection into a new collection with equal length arrays as its items.\n\t         *\n\t         * @param  {number} size the size of each chunk.\n\t         * @return {Collection} the new collection.\n\t         * @example\n\t         * const collection = new Collection([1, 2, 3, 4, 5]).chunk(2);\n\t         * console.log(collection.all()); // [[1, 2], [3, 4], [5]]\n\t         */\n\t\n\t    }, {\n\t        key: 'chunk',\n\t        value: function chunk(size) {\n\t            if (size <= 0) {\n\t                return new Collection();\n\t            }\n\t\n\t            var items = [];\n\t\n\t            for (var i = 0; i < this.count(); i += size) {\n\t                items.push(this.items.slice(i, i + size));\n\t            }\n\t\n\t            return new Collection(items);\n\t        }\n\t\n\t        /**\n\t         * Static constructor.\n\t         * cool if you don't like using the 'new' keyword.\n\t         *\n\t         * @param  {Array} collectable the array or the string to wrapped in a collection.\n\t         * @return {Collection} A collection that wraps the collectable items.\n\t         * @example\n\t         * const collection = Collection.collect([1, 2, 3]);\n\t         * console.log(collection.all()); // [1, 2, 3]\n\t         */\n\t\n\t    }, {\n\t        key: 'concat',\n\t\n\t\n\t        /**\n\t         * Concatnates the collection with an array or another collection.\n\t         *\n\t         * @param {Array|Collection} collection the array or the collection to be concatenated with.\n\t         * @return {Collection} concatenated collection.\n\t         * @example\n\t         * const collection = new Collection([1, 2, 3]);\n\t         * const array = [4, 5, 6]; // or another collection.\n\t         * const newCollection = collection.concat(array);\n\t         * console.log(newCollection.all()); // [1, 2, 3, 4, 5, 6]\n\t         */\n\t        value: function concat(collection) {\n\t            if (Array.isArray(collection)) {\n\t                return new Collection(this.items.concat(collection));\n\t            }\n\t\n\t            return new Collection(this.items.concat(collection.all()));\n\t        }\n\t\n\t        /**\n\t         * Checks if there is at least one occurance of an element using a closure.\n\t         * @param  {function} closure The closure the be used on each element.\n\t         * @return {boolean} true if at least one occurance exist, false otherwise.\n\t         * @example\n\t         * const collection = new Collection([\n\t         *     { name: 'John Snow', age: 14 },\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Arya Stark', age: 9 }\n\t         * ]);\n\t         *\n\t         * collection.contains(stark => stark.name === 'John Snow'); // true\n\t         * collection.contains(stark => stark.name === 'Eddard Stark'); // false\n\t         */\n\t\n\t    }, {\n\t        key: 'contains',\n\t        value: function contains(closure) {\n\t            return !!this.first(closure);\n\t        }\n\t\n\t        /**\n\t         * Gets the number of items in the collection.\n\t         *\n\t         * @return {number} Number of items in the collection.\n\t         * @example\n\t         * const collection = new Collection([1, 2, 3]);\n\t         * console.log(collection.count()); // 3\n\t         */\n\t\n\t    }, {\n\t        key: 'count',\n\t        value: function count() {\n\t            return this.items.length;\n\t        }\n\t\n\t        /**\n\t         * Executes a callback for each element in the collection.\n\t         *\n\t         * @param  {function} callback the callback to be excuted for each item.\n\t         * @return {Collection} The collection object.\n\t         * @example\n\t         * const collection = new Collection(['this', 'is', 'collectionjs']);\n\t         * collection.each(t => console.log(t)); // this is collectionjs\n\t         */\n\t\n\t    }, {\n\t        key: 'each',\n\t        value: function each(callback) {\n\t            this.items.forEach(callback);\n\t\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Filters the collection using a predicate (callback that returns a boolean).\n\t         *\n\t         * @param  {function} callback A function that returns a boolean expression.\n\t         * @return {Collection} Filtered collection.\n\t         * @example\n\t         * const collection = new Collection([\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]).filter(stark => stark.age === 14);\n\t         * console.log(collection.all()); // [{ name: 'Jon Snow', age: 14 }]\n\t         */\n\t\n\t    }, {\n\t        key: 'filter',\n\t        value: function filter(callback) {\n\t            return new Collection(this.items.filter(callback));\n\t        }\n\t\n\t        /**\n\t         * Returns the index of an element.\n\t         *\n\t         * @param  {*} item The item to be searched.\n\t         * @return {number} The index of the item. -1 means it wasn't found.\n\t         * @example\n\t         * const collection = new Collection(['jon', 'arya', 'bran']);\n\t         * console.log(collection.find('bran')); // 2\n\t         * console.log(collection.find('ed')); // -1\n\t         */\n\t\n\t    }, {\n\t        key: 'find',\n\t        value: function find(item) {\n\t            return this.items.indexOf(item);\n\t        }\n\t\n\t        /**\n\t         * Gets the first element satisfying a critera.\n\t         *\n\t         * @param  {function} [callback=null] the predicate (callback) that will be applied on items.\n\t         * @return {*} the first item to satisfy the critera.\n\t         * @example <caption>Using a callback</caption>\n\t         * const first = new Collection([\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]).first(item => item.age > 7);\n\t         *\n\t         * console.log(first); // { name: 'Arya Stark', age: 9 }\n\t         * @example <caption>No Arguments</caption>\n\t         * const first = new Collection([\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]).first();\n\t         *\n\t         * console.log(first); // { name: 'Bran Stark', age: 7 }\n\t         */\n\t\n\t    }, {\n\t        key: 'first',\n\t        value: function first() {\n\t            var callback = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];\n\t\n\t            if (!this.count()) {\n\t                return null;\n\t            }\n\t\n\t            if (callback && typeof callback === 'function') {\n\t                for (var i = 0; i < this.count(); i++) {\n\t                    if (callback(this.items[i])) {\n\t                        return this.items[i];\n\t                    }\n\t                }\n\t\n\t                return null;\n\t            }\n\t\n\t            return this.items[0];\n\t        }\n\t\n\t        /**\n\t         * Flattens the collection elements.\n\t         *\n\t         * @param  {Boolean} [deep=false] recursively flatten the items (multi-level).\n\t         * @return {Collection} the flattened collection.\n\t         * @example <caption>Just one level</caption>\n\t         * const collection = new Collection([1, [2, [3, [4]], 5]]).flatten();\n\t         * console.log(collection.all()); // [1, 2, [3, [4]], 5]\n\t         *\n\t         * @example <caption>Deep</caption>\n\t         * const collection = new Collection([1, [2, [3, [4]], 5]]).flatten(true);\n\t         * console.log(collection.all()); // [1, 2, 3, 4, 5]\n\t         */\n\t\n\t    }, {\n\t        key: 'flatten',\n\t        value: function flatten() {\n\t            var _ref;\n\t\n\t            var deep = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\t\n\t            var flattened = new Collection((_ref = []).concat.apply(_ref, _toConsumableArray(this.items)));\n\t\n\t            if (!deep || !flattened.contains(Array.isArray)) {\n\t                return flattened;\n\t            }\n\t\n\t            return flattened.flatten(true);\n\t        }\n\t\n\t        /**\n\t         * Gets an element at a specified index.\n\t         *\n\t         * @param  {number} index the index of the item.\n\t         * @return {*} the item at that index.\n\t         * @example\n\t         * const collection = new Collection([1, 2, 3]);\n\t         * console.log(collection.get(2)); // 3\n\t         */\n\t\n\t    }, {\n\t        key: 'get',\n\t        value: function get(index) {\n\t            return this.items[index];\n\t        }\n\t\n\t        /**\n\t         * Checks if a collection has a specific item.\n\t         *\n\t         * @param  {*}  item The item to be searched.\n\t         * @return {boolean} true if exists, false otherwise.\n\t         * @example\n\t         * const collection = new Collection([1, 2, 3, 4]);\n\t         *\n\t         * console.log(collection.has(2)); // true\n\t         * console.log(collection.has(5)); // false\n\t         */\n\t\n\t    }, {\n\t        key: 'has',\n\t        value: function has(item) {\n\t            return !!~this.find(item);\n\t        }\n\t\n\t        /**\n\t         * Joins the collection elements into a string.\n\t         *\n\t         * @param  {string} [seperator=','] The seperator between each element and the next.\n\t         * @return {string} The joined string.\n\t         *\n\t         * @example\n\t         * const collection = new Collection(['Wind', 'Rain', 'Fire']);\n\t         * console.log(collection.join()); // 'Wind,Rain,Fire'\n\t         * console.log(collection.join(', ')); 'Wind, Rain, Fire'\n\t         */\n\t\n\t    }, {\n\t        key: 'join',\n\t        value: function join() {\n\t            var seperator = arguments.length <= 0 || arguments[0] === undefined ? ',' : arguments[0];\n\t\n\t            return this.items.join(seperator);\n\t        }\n\t\n\t        /**\n\t         * Gets the collection elements keys in a new collection.\n\t         *\n\t         * @return {Collection} The keys collection.\n\t         * @example <caption>Objects</caption>\n\t         * const keys = new Collection({\n\t         *     arya: 10,\n\t         *     john: 20,\n\t         *     potato: 30\n\t         * }).keys();\n\t         * console.log(keys); // ['arya', 'john', 'potato']\n\t         *\n\t         * @example <caption>Regular Array</caption>\n\t         * const keys = new Collection(['arya', 'john', 'potato']).keys();\n\t         * console.log(keys); // ['0', '1', '2']\n\t         */\n\t\n\t    }, {\n\t        key: 'keys',\n\t        value: function keys() {\n\t            return new Collection(Object.keys(this.items));\n\t        }\n\t\n\t        /**\n\t         * Gets the last element to satisfy a callback.\n\t         *\n\t         * @param  {function} [callback=null] the predicate to be checked on all elements.\n\t         * @return {*} The last element in the collection that satisfies the predicate.\n\t         * @example <caption>Using a callback</caption>\n\t         * const last = new Collection([\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]).last(item => item.age > 7);\n\t         *\n\t         * console.log(last); // { name: 'Jon Snow', age: 14 }\n\t         * @example <caption>No Arguments</caption>\n\t         * const last = new Collection([\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]).last();\n\t         *\n\t         * console.log(last); // { name: 'Jon Snow', age: 14 }\n\t         */\n\t\n\t    }, {\n\t        key: 'last',\n\t        value: function last() {\n\t            var callback = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];\n\t\n\t            if (!this.count()) {\n\t                return null;\n\t            }\n\t\n\t            if (callback && typeof callback === 'function') {\n\t                return this.filter(callback).last();\n\t            }\n\t\n\t            return this.items[this.count() - 1];\n\t        }\n\t\n\t        /**\n\t         * Maps each element using a mapping function and collects the mapped items.\n\t         * @param  {function} callback the mapping function.\n\t         * @return {Collection} collection containing the mapped items.\n\t         * @example\n\t         * const collection = new Collection([\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]).map(stark => stark.name);\n\t         * console.log(collection.all()); ['Bran Stark', 'Arya Stark', 'Jon Snow']\n\t         */\n\t\n\t    }, {\n\t        key: 'map',\n\t        value: function map(callback) {\n\t            return new Collection(this.items.map(callback));\n\t        }\n\t\n\t        /**\n\t         * Extracts a property from the objects in the collection.\n\t         *\n\t         * @param  {string} property the name of the property to be extracted.\n\t         * @return {Collection} A collection with the extracted items.\n\t         * @example\n\t         * const collection = new Collection([\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]).pluck('name');\n\t         * console.log(collection.all()); ['Bran Stark', 'Arya Stark', 'Jon Snow']\n\t         */\n\t\n\t    }, {\n\t        key: 'pluck',\n\t        value: function pluck(property) {\n\t            return this.map(function (item) {\n\t                return item[property];\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Adds an element to the collection.\n\t         *\n\t         * @param  {*} item the item to be added.\n\t         * @return {Collection} The collection object.\n\t         * @example\n\t         * const collection = new Collection().push('First');\n\t         * console.log(collection.first()); // \"First\"\n\t         */\n\t\n\t    }, {\n\t        key: 'push',\n\t        value: function push(item) {\n\t            return this.add(item);\n\t        }\n\t\n\t        /**\n\t         * Reduces the collection to a single value using a reducing function.\n\t         *\n\t         * @param  {function} callback the reducing function.\n\t         * @param  {*} initial  initial value.\n\t         * @return {*} The reduced results.\n\t         * @example\n\t         * const value = new Collection([1, 2, 3]).reduce(\n\t         *     (previous, current) => previous + current,\n\t         *      0\n\t         *  );\n\t         *  console.log(value); // 6\n\t         */\n\t\n\t    }, {\n\t        key: 'reduce',\n\t        value: function reduce(callback, initial) {\n\t            return this.items.reduce(callback, initial);\n\t        }\n\t\n\t        /**\n\t         * Removes the elements that do not satisfy the predicate.\n\t         *\n\t         * @param  {function} callback the predicate used on each item.\n\t         * @return {Collection} A collection without the rejected elements.\n\t         * @example\n\t         * const collection = new Collection([\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]).reject(stark => stark.age < 14);\n\t         * console.log(collection.all()); // [{ name: 'Jon Snow', age: 14 }]\n\t         */\n\t\n\t    }, {\n\t        key: 'reject',\n\t        value: function reject(callback) {\n\t            var items = [];\n\t            this.items.forEach(function (item) {\n\t                if (!callback(item)) {\n\t                    items.push(item);\n\t                }\n\t            });\n\t\n\t            return new Collection(items);\n\t        }\n\t\n\t        /**\n\t         * Removes an item from the collection.\n\t         *\n\t         * @param  {*} item the item to be searched and removed, first occurance will be removed.\n\t         * @return {boolean} True if the element was removed, false otherwise.\n\t         * @example\n\t         * const collection = new Collection(['john', 'arya', 'bran']);\n\t         * collection.remove('john');\n\t         * console.log(collection.all()); // ['arya', 'bran']\n\t         */\n\t\n\t    }, {\n\t        key: 'remove',\n\t        value: function remove(item) {\n\t            var index = this.find(item);\n\t            if (~index) {\n\t                this.items.splice(index, 1);\n\t\n\t                return true;\n\t            }\n\t\n\t            return false;\n\t        }\n\t\n\t        /**\n\t         * Reverses the collection order.\n\t         *\n\t         * @return {Collection} A new collection with the reversed order.\n\t         * @example\n\t         * const collection = new Collection(['one', 'two', 'three']).reverse();\n\t         * console.log(collection.all()); // ['three', 'two', 'one']\n\t         */\n\t\n\t    }, {\n\t        key: 'reverse',\n\t        value: function reverse() {\n\t            return new Collection(this.items.reverse());\n\t        }\n\t\n\t        /**\n\t         * Skips a specified number of elements.\n\t         *\n\t         * @param  {number} count the number of items to be skipped.\n\t         * @return {Collection} A collection without the skipped items.\n\t         * @example\n\t         * const collection = new Collection(['John', 'Arya', 'Bran', 'Sansa']).skip(2);\n\t         * console.log(collection.all()); // ['Bran', 'Sansa']\n\t         */\n\t\n\t    }, {\n\t        key: 'skip',\n\t        value: function skip(count) {\n\t            return this.slice(count);\n\t        }\n\t\n\t        /**\n\t         * Slices the collection starting from a specific index and ending at a specified index.\n\t         *\n\t         * @param  {number} start The zero-based starting index.\n\t         * @param  {number} [end=length] The zero-based ending index.\n\t         * @return {Collection} A collection with the sliced items.\n\t         * @example <caption>start and end are specified</caption>\n\t         * const collection = new Collection([0, 1, 2, 3, 4, 5, 6]).slice(2, 4);\n\t         * console.log(collection.all()); // [2, 3]\n\t         *\n\t         * @example <caption>only start is specified</caption>\n\t         * const collection = new Collection([0, 1, 2, 3, 4, 5, 6]).slice(2);\n\t         * console.log(collection.all()); // [2, 3, 4, 5, 6]\n\t         */\n\t\n\t    }, {\n\t        key: 'slice',\n\t        value: function slice(start) {\n\t            var end = arguments.length <= 1 || arguments[1] === undefined ? this.items.length : arguments[1];\n\t\n\t            return new Collection(this.items.slice(start, end));\n\t        }\n\t\n\t        /**\n\t         * Sorts the elements of a collection and returns a new sorted collection.\n\t         * note that it doesn't change the orignal collection and it creates a\n\t         * shallow copy.\n\t         *\n\t         * @param  {function} [compare=undefined] the compare function.\n\t         * @return {Collection} A new collection with the sorted items.\n\t         *\n\t         * @example\n\t         * const collection = new Collection([5, 3, 4, 1, 2]);\n\t         * const sorted = collection.sort();\n\t         * // original collection is intact.\n\t         * console.log(collection.all()); // [5, 3, 4, 1, 2]\n\t         * console.log(sorted.all()); // [1, 2, 3, 4, 5]\n\t         */\n\t\n\t    }, {\n\t        key: 'sort',\n\t        value: function sort() {\n\t            var compare = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n\t\n\t            return new Collection(this.items.slice().sort(compare));\n\t        }\n\t\n\t        /**\n\t         * Sorts the collection by key value comaprison, given that the items are objects.\n\t         * It creates a shallow copy and retains the order of the orignal collection.\n\t         *\n\t         * @param  {string} property the key or the property to be compared.\n\t         * @param  {string} [order='asc'] The sorting order.\n\t         * use 'asc' for ascending or 'desc' for descending, case insensitive.\n\t         * @return {Collection} A new Collection with the sorted items.\n\t         *\n\t         * @example\n\t         * const collection = new Collection([\n\t         *     { name: 'Jon Snow', age: 14 },\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         * ]).sortBy('age');\n\t         *\n\t         * console.log(collection.pluck('name').all()); // ['Brand Stark', 'Arya Stark', 'Jon Snow']\n\t         */\n\t\n\t    }, {\n\t        key: 'sortBy',\n\t        value: function sortBy(property) {\n\t            var order = arguments.length <= 1 || arguments[1] === undefined ? 'asc' : arguments[1];\n\t\n\t            var isAscending = order.toLowerCase() === 'asc';\n\t\n\t            return this.sort(function (a, b) {\n\t                if (a[property] > b[property]) {\n\t                    return isAscending ? 1 : -1;\n\t                }\n\t\n\t                if (a[property] < b[property]) {\n\t                    return isAscending ? -1 : 1;\n\t                }\n\t\n\t                return 0;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * {stringifies the collection using JSON.stringify API.\n\t         *\n\t         * @return {string} The stringified value.\n\t         * @example\n\t         * const collection = new Collection([1, 2, 3]);\n\t         * console.log(collection.stringify()); // \"[1,2,3]\"\n\t         */\n\t\n\t    }, {\n\t        key: 'stringify',\n\t        value: function stringify() {\n\t            return JSON.stringify(this.items);\n\t        }\n\t\n\t        /**\n\t         * Sums the values of the array, or the properties, or the result of the callback.\n\t         *\n\t         * @param  {undefined|string|function} [property=null] the property to be summed.\n\t         * @return {*} The sum of values used in the summation.\n\t         * @example <caption>Summing elements</caption>\n\t         * const collection = new Collection([1, 2, 3]);\n\t         * console.log(collection.sum()); // 6\n\t         *\n\t         * @example <caption>Summing a property</caption>\n\t         * const collection = new Collection([\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]);\n\t         * console.log(collection.sum('age')); // 30\n\t         *\n\t         * @example <caption>Summing using a callback</caption>\n\t         * const collection = new Collection([\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]);\n\t         * console.log(collection.sum(i => i.age + 1)); // 33\n\t         */\n\t\n\t    }, {\n\t        key: 'sum',\n\t        value: function sum() {\n\t            var property = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];\n\t\n\t            if (typeof property === 'string') {\n\t                return this.reduce(function (previous, current) {\n\t                    return previous + current[property];\n\t                }, 0);\n\t            }\n\t\n\t            if (typeof property === 'function') {\n\t                return this.reduce(function (previous, current) {\n\t                    return previous + property(current);\n\t                }, 0);\n\t            }\n\t\n\t            return this.reduce(function (previous, current) {\n\t                return previous + current;\n\t            }, 0);\n\t        }\n\t\n\t        /**\n\t         * Gets a new collection with the number of specified items from the begining or the end.\n\t         *\n\t         * @param  {number} count the number of items to take. Takes from end if negative.\n\t         * @return {Collection} A collection with the taken items.\n\t         * @example <caption>From the beginning</caption>\n\t         * const collection = new Collection([1, 2, 3, 4, 5]).take(3);\n\t         * console.log(collection.all()); // [1, 2, 3]\n\t         *\n\t         * @example <caption>From the end</caption>\n\t         * const collection = new Collection([1, 2, 3, 4, 5]).take(-3);\n\t         * console.log(collection.all()); // [5, 4 ,3]\n\t         */\n\t\n\t    }, {\n\t        key: 'take',\n\t        value: function take(count) {\n\t            if (!count) {\n\t                return new Collection([]);\n\t            }\n\t\n\t            if (count < 0) {\n\t                return new Collection(this.items.reverse()).take(-count);\n\t            }\n\t\n\t            return new Collection(this.items.slice(0, count));\n\t        }\n\t\n\t        /**\n\t         * Registers a new method on the collection prototype for future use.\n\t         * The closure gets the collection object passed as the first parameter then\n\t         * other parameters gets passed after.\n\t         *\n\t         * @param  {string} name The name of the macro function.\n\t         * @param  {function} callback A closure containing the behavior of the macro.\n\t         * @return {*} returns your callback result.\n\t         *\n\t         * @example\n\t         * Collection.macro('addToMembers', (collection, n) => collection.map(item => item + n));\n\t         * const col2 = new Collection([1, 2, 3, 4]).addToMembers(3);\n\t         * console.log(col2.all()); // [4, 5, 6, 7]\n\t         */\n\t\n\t    }, {\n\t        key: 'unique',\n\t\n\t\n\t        /**\n\t         * Remove duplicate values from the collection.\n\t         *\n\t         * @param {function|string} [callback=null] The predicate that returns a value\n\t         * which will be checked for uniqueness, or a string that has the name of the property.\n\t         * @return {Collection} A collection containing ue values.\n\t         * @example <caption>No Arguments</caption>\n\t         * const unique = new Collection([2, 1, 2, 3, 3, 4, 5, 1, 2]).unique();\n\t         * console.log(unique); // [2, 1, 3, 4, 5]\n\t         * @example <caption>Property Name</caption>\n\t         * const students = new Collection([\n\t         * \t\t{ name: 'Rick', grade: 'A'},\n\t         * \t\t{ name: 'Mick', grade: 'B'},\n\t         * \t\t{ name: 'Richard', grade: 'A'},\n\t         * ]);\n\t         * // Students with unique grades.\n\t         * students.unique('grade'); // [{ name: 'Rick', grade: 'A'}, { name: 'Mick', grade: 'B'}]\n\t         * @example <caption>With Callback</caption>\n\t         * const students = new Collection([\n\t         * \t\t{ name: 'Rick', grade: 'A'},\n\t         * \t\t{ name: 'Mick', grade: 'B'},\n\t         * \t\t{ name: 'Richard', grade: 'A'},\n\t         * ]);\n\t         * // Students with unique grades.\n\t         * students.unique(s => s.grade); // [{ name: 'Rick', grade: 'A'}, { name: 'Mick', grade: 'B'}]\n\t         */\n\t        value: function unique() {\n\t            var _this = this;\n\t\n\t            var callback = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];\n\t\n\t            if (typeof callback === 'string') {\n\t                return this.unique(function (item) {\n\t                    return item[callback];\n\t                });\n\t            }\n\t\n\t            if (callback) {\n\t                var _ret = function () {\n\t                    var mappedCollection = new Collection();\n\t\n\t                    return {\n\t                        v: _this.reduce(function (collection, item) {\n\t                            var mappedItem = callback(item);\n\t                            if (!mappedCollection.has(mappedItem)) {\n\t                                collection.add(item);\n\t                                mappedCollection.add(mappedItem);\n\t                            }\n\t\n\t                            return collection;\n\t                        }, new Collection())\n\t                    };\n\t                }();\n\t\n\t                if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t            }\n\t\n\t            return this.reduce(function (collection, item) {\n\t                if (!collection.has(item)) {\n\t                    collection.add(item);\n\t                }\n\t\n\t                return collection;\n\t            }, new Collection());\n\t        }\n\t\n\t        /**\n\t         * Gets the values without preserving the keys.\n\t         *\n\t         * @return {Collection} A Collection containing the values.\n\t         * @example\n\t         * const collection = new Collection({\n\t         *     1: 2,\n\t         *     2: 3,\n\t         *     4: 5\n\t         * }).values();\n\t         *\n\t         * console.log(collection.all()); / /[2, 3, 5]\n\t         */\n\t\n\t    }, {\n\t        key: 'values',\n\t        value: function values() {\n\t            var _this2 = this;\n\t\n\t            return this.keys().map(function (key) {\n\t                return _this2.items[key];\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Filters the collection using a callback or equality comparison to a property in each item.\n\t         *\n\t         * @param  {function|string} callback The callback to be used to filter the collection.\n\t         * @param  {*} [value=null] The value to be compared.\n\t         * @return {Collection} A collection with the filtered items.\n\t         * @example <caption>Using a property name</caption>\n\t         * const collection = new Collection([\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]).where('age', 14);\n\t         * console.log(collection.all()); // [{ name: 'Jon Snow', age: 14 }]\n\t         *\n\t         * @example <caption>Using a callback</caption>\n\t         * const collection = new Collection([\n\t         *     { name: 'Arya Stark', age: 9 },\n\t         *     { name: 'Bran Stark', age: 7 },\n\t         *     { name: 'Jon Snow', age: 14 }\n\t         * ]).where(stark => stark.age === 14);\n\t         * console.log(collection.all()); // [{ name: 'Jon Snow', age: 14 }]\n\t         */\n\t\n\t    }, {\n\t        key: 'where',\n\t        value: function where(callback) {\n\t            var value = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\t\n\t            if (typeof callback === 'string') {\n\t                return this.filter(function (item) {\n\t                    return item[callback] === value;\n\t                });\n\t            }\n\t\n\t            return this.filter(callback);\n\t        }\n\t\n\t        /**\n\t         * Pairs each item in the collection with another array item in the same index.\n\t         *\n\t         * @param  {Array|Collection} array the array to be paired with.\n\t         * @return {Collection} A collection with the paired items.\n\t         * @example\n\t         * const array = ['a', 'b', 'c']; // or a collection.\n\t         * const collection = new Collection([1, 2, 3]).zip(array);\n\t         * console.log(collection.all()); // [[1, 'a'], [2, 'b'], [3, 'c']]\n\t         */\n\t\n\t    }, {\n\t        key: 'zip',\n\t        value: function zip(array) {\n\t            if (array instanceof Collection) {\n\t                return this.map(function (item, index) {\n\t                    return [item, array.get(index)];\n\t                });\n\t            }\n\t\n\t            return this.map(function (item, index) {\n\t                return [item, array[index]];\n\t            });\n\t        }\n\t    }], [{\n\t        key: 'collect',\n\t        value: function collect(collectable) {\n\t            return new Collection(collectable);\n\t        }\n\t    }, {\n\t        key: 'macro',\n\t        value: function macro(name, callback) {\n\t            if (Collection.prototype[name] !== undefined) {\n\t                throw new Error('Collection.macro(): This macro name is already defined.');\n\t            }\n\t\n\t            Collection.prototype[name] = function collectionMacroWrapper() {\n\t                var collection = this;\n\t\n\t                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t                    args[_key] = arguments[_key];\n\t                }\n\t\n\t                return callback.apply(undefined, [collection].concat(args));\n\t            };\n\t        }\n\t    }]);\n\t\n\t    return Collection;\n\t}();\n\t\n\texports.default = Collection;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** collection.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 93e2d95ecb3671964260\n **/","/**\n * The Collection object.\n *\n * @example\n * let collection = new Collection([1, 2, 3]);\n */\nexport default class Collection\n{\n    /**\n     * The collection constructor.\n     *\n     * @param  {Array} [items=[]] the array to collect.\n     * @return {Collection} A Collection object.\n     */\n    constructor(items = []) {\n        /**\n         * The internal array.\n         * @type {Array|Object}\n         */\n        this.items = items;\n    }\n\n    /**\n     * Adds an item to the collection.\n     *\n     * @param {*} item the item to be added.\n     * @return {Collection} the collection object.\n     * @example\n     * const collection = new Collection();\n     * collection.add('Arya');\n     * console.log(collection.first()); //outputs 'Arya'\n     */\n    add(item) {\n        this.items.push(item);\n\n        return this;\n    }\n\n    /**\n     * Gets the collected elements in an array.\n     *\n     * @return {Array} the internal array.\n     * @example\n     * const collection = new Collection([1, 2, 3]);\n     * console.log(collection.all()); // [1, 2, 3]\n     */\n    all() {\n        return this.items;\n    }\n\n    /**\n     * Gets the average value of the array or a property or a callback return value.\n     * If no property is provided: it will calculate the average value of the array (Numeric array).\n     * If property is a string: it will calculate the average value of that property for all\n     *  objects in the array.\n     * If Property is a callback: the the averaging will use the value returned instead.\n     *\n     * @param  {function|string} [property=null] The property name or the callback function.\n     * defaults to null.\n     * @return {number} The average value.\n     * @example <caption>Averaging elements</caption>\n     * const collection = new Collection([1, 2, 3]);\n     * console.log(collection.average()); // 2\n     * @example <caption>Averaging a property</caption>\n     * const collection = new Collection([\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]);\n     * console.log(collection.average('age')); // 10\n     * @example <caption>Averaging using a callback</caption>\n     * const collection = new Collection([\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]);\n     * console.log(collection.average(i => i.age)); // 10\n     */\n    average(property = null) {\n        return this.sum(property) / this.count();\n    }\n\n    /**\n     * Chunks the collection into a new collection with equal length arrays as its items.\n     *\n     * @param  {number} size the size of each chunk.\n     * @return {Collection} the new collection.\n     * @example\n     * const collection = new Collection([1, 2, 3, 4, 5]).chunk(2);\n     * console.log(collection.all()); // [[1, 2], [3, 4], [5]]\n     */\n    chunk(size) {\n        if (size <= 0) {\n            return new Collection();\n        }\n\n        const items = [];\n\n        for (let i = 0; i < this.count(); i += size) {\n            items.push(this.items.slice(i, i + size));\n        }\n\n        return new Collection(items);\n    }\n\n    /**\n     * Static constructor.\n     * cool if you don't like using the 'new' keyword.\n     *\n     * @param  {Array} collectable the array or the string to wrapped in a collection.\n     * @return {Collection} A collection that wraps the collectable items.\n     * @example\n     * const collection = Collection.collect([1, 2, 3]);\n     * console.log(collection.all()); // [1, 2, 3]\n     */\n    static collect(collectable) {\n        return new Collection(collectable);\n    }\n\n    /**\n     * Concatnates the collection with an array or another collection.\n     *\n     * @param {Array|Collection} collection the array or the collection to be concatenated with.\n     * @return {Collection} concatenated collection.\n     * @example\n     * const collection = new Collection([1, 2, 3]);\n     * const array = [4, 5, 6]; // or another collection.\n     * const newCollection = collection.concat(array);\n     * console.log(newCollection.all()); // [1, 2, 3, 4, 5, 6]\n     */\n    concat(collection) {\n        if (Array.isArray(collection)) {\n            return new Collection(this.items.concat(collection));\n        }\n\n        return new Collection(this.items.concat(collection.all()));\n    }\n\n    /**\n     * Checks if there is at least one occurance of an element using a closure.\n     * @param  {function} closure The closure the be used on each element.\n     * @return {boolean} true if at least one occurance exist, false otherwise.\n     * @example\n     * const collection = new Collection([\n     *     { name: 'John Snow', age: 14 },\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Arya Stark', age: 9 }\n     * ]);\n     *\n     * collection.contains(stark => stark.name === 'John Snow'); // true\n     * collection.contains(stark => stark.name === 'Eddard Stark'); // false\n     */\n    contains(closure) {\n        return !! this.first(closure);\n    }\n\n    /**\n     * Gets the number of items in the collection.\n     *\n     * @return {number} Number of items in the collection.\n     * @example\n     * const collection = new Collection([1, 2, 3]);\n     * console.log(collection.count()); // 3\n     */\n    count() {\n        return this.items.length;\n    }\n\n\n    /**\n     * Executes a callback for each element in the collection.\n     *\n     * @param  {function} callback the callback to be excuted for each item.\n     * @return {Collection} The collection object.\n     * @example\n     * const collection = new Collection(['this', 'is', 'collectionjs']);\n     * collection.each(t => console.log(t)); // this is collectionjs\n     */\n    each(callback) {\n        this.items.forEach(callback);\n\n        return this;\n    }\n\n    /**\n     * Filters the collection using a predicate (callback that returns a boolean).\n     *\n     * @param  {function} callback A function that returns a boolean expression.\n     * @return {Collection} Filtered collection.\n     * @example\n     * const collection = new Collection([\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]).filter(stark => stark.age === 14);\n     * console.log(collection.all()); // [{ name: 'Jon Snow', age: 14 }]\n     */\n    filter(callback) {\n        return new Collection(this.items.filter(callback));\n    }\n\n    /**\n     * Returns the index of an element.\n     *\n     * @param  {*} item The item to be searched.\n     * @return {number} The index of the item. -1 means it wasn't found.\n     * @example\n     * const collection = new Collection(['jon', 'arya', 'bran']);\n     * console.log(collection.find('bran')); // 2\n     * console.log(collection.find('ed')); // -1\n     */\n    find(item) {\n        return this.items.indexOf(item);\n    }\n\n    /**\n     * Gets the first element satisfying a critera.\n     *\n     * @param  {function} [callback=null] the predicate (callback) that will be applied on items.\n     * @return {*} the first item to satisfy the critera.\n     * @example <caption>Using a callback</caption>\n     * const first = new Collection([\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]).first(item => item.age > 7);\n     *\n     * console.log(first); // { name: 'Arya Stark', age: 9 }\n     * @example <caption>No Arguments</caption>\n     * const first = new Collection([\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]).first();\n     *\n     * console.log(first); // { name: 'Bran Stark', age: 7 }\n     */\n    first(callback = null) {\n        if (! this.count()) {\n            return null;\n        }\n\n        if (callback && typeof(callback) === 'function') {\n            for (let i = 0; i < this.count(); i++) {\n                if (callback(this.items[i])) {\n                    return this.items[i];\n                }\n            }\n\n            return null;\n        }\n\n        return this.items[0];\n    }\n\n    /**\n     * Flattens the collection elements.\n     *\n     * @param  {Boolean} [deep=false] recursively flatten the items (multi-level).\n     * @return {Collection} the flattened collection.\n     * @example <caption>Just one level</caption>\n     * const collection = new Collection([1, [2, [3, [4]], 5]]).flatten();\n     * console.log(collection.all()); // [1, 2, [3, [4]], 5]\n     *\n     * @example <caption>Deep</caption>\n     * const collection = new Collection([1, [2, [3, [4]], 5]]).flatten(true);\n     * console.log(collection.all()); // [1, 2, 3, 4, 5]\n     */\n    flatten(deep = false) {\n        const flattened = new Collection([].concat(...this.items));\n\n        if (! deep || ! flattened.contains(Array.isArray)) {\n            return flattened;\n        }\n\n        return flattened.flatten(true);\n    }\n\n    /**\n     * Gets an element at a specified index.\n     *\n     * @param  {number} index the index of the item.\n     * @return {*} the item at that index.\n     * @example\n     * const collection = new Collection([1, 2, 3]);\n     * console.log(collection.get(2)); // 3\n     */\n    get(index) {\n        return this.items[index];\n    }\n\n    /**\n     * Checks if a collection has a specific item.\n     *\n     * @param  {*}  item The item to be searched.\n     * @return {boolean} true if exists, false otherwise.\n     * @example\n     * const collection = new Collection([1, 2, 3, 4]);\n     *\n     * console.log(collection.has(2)); // true\n     * console.log(collection.has(5)); // false\n     */\n    has(item) {\n        return !! ~this.find(item);\n    }\n\n    /**\n     * Joins the collection elements into a string.\n     *\n     * @param  {string} [seperator=','] The seperator between each element and the next.\n     * @return {string} The joined string.\n     *\n     * @example\n     * const collection = new Collection(['Wind', 'Rain', 'Fire']);\n     * console.log(collection.join()); // 'Wind,Rain,Fire'\n     * console.log(collection.join(', ')); 'Wind, Rain, Fire'\n     */\n    join(seperator = ',') {\n        return this.items.join(seperator);\n    }\n\n    /**\n     * Gets the collection elements keys in a new collection.\n     *\n     * @return {Collection} The keys collection.\n     * @example <caption>Objects</caption>\n     * const keys = new Collection({\n     *     arya: 10,\n     *     john: 20,\n     *     potato: 30\n     * }).keys();\n     * console.log(keys); // ['arya', 'john', 'potato']\n     *\n     * @example <caption>Regular Array</caption>\n     * const keys = new Collection(['arya', 'john', 'potato']).keys();\n     * console.log(keys); // ['0', '1', '2']\n     */\n    keys() {\n        return new Collection(Object.keys(this.items));\n    }\n\n    /**\n     * Gets the last element to satisfy a callback.\n     *\n     * @param  {function} [callback=null] the predicate to be checked on all elements.\n     * @return {*} The last element in the collection that satisfies the predicate.\n     * @example <caption>Using a callback</caption>\n     * const last = new Collection([\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]).last(item => item.age > 7);\n     *\n     * console.log(last); // { name: 'Jon Snow', age: 14 }\n     * @example <caption>No Arguments</caption>\n     * const last = new Collection([\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]).last();\n     *\n     * console.log(last); // { name: 'Jon Snow', age: 14 }\n     */\n    last(callback = null) {\n        if (! this.count()) {\n            return null;\n        }\n\n        if (callback && typeof(callback) === 'function') {\n            return this.filter(callback).last();\n        }\n\n        return this.items[this.count() - 1];\n    }\n\n    /**\n     * Maps each element using a mapping function and collects the mapped items.\n     * @param  {function} callback the mapping function.\n     * @return {Collection} collection containing the mapped items.\n     * @example\n     * const collection = new Collection([\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]).map(stark => stark.name);\n     * console.log(collection.all()); ['Bran Stark', 'Arya Stark', 'Jon Snow']\n     */\n    map(callback) {\n        return new Collection(this.items.map(callback));\n    }\n\n    /**\n     * Extracts a property from the objects in the collection.\n     *\n     * @param  {string} property the name of the property to be extracted.\n     * @return {Collection} A collection with the extracted items.\n     * @example\n     * const collection = new Collection([\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]).pluck('name');\n     * console.log(collection.all()); ['Bran Stark', 'Arya Stark', 'Jon Snow']\n     */\n    pluck(property) {\n        return this.map((item) => item[property]);\n    }\n\n    /**\n     * Adds an element to the collection.\n     *\n     * @param  {*} item the item to be added.\n     * @return {Collection} The collection object.\n     * @example\n     * const collection = new Collection().push('First');\n     * console.log(collection.first()); // \"First\"\n     */\n    push(item) {\n        return this.add(item);\n    }\n\n    /**\n     * Reduces the collection to a single value using a reducing function.\n     *\n     * @param  {function} callback the reducing function.\n     * @param  {*} initial  initial value.\n     * @return {*} The reduced results.\n     * @example\n     * const value = new Collection([1, 2, 3]).reduce(\n     *     (previous, current) => previous + current,\n     *      0\n     *  );\n     *  console.log(value); // 6\n     */\n    reduce(callback, initial) {\n        return this.items.reduce(callback, initial);\n    }\n\n    /**\n     * Removes the elements that do not satisfy the predicate.\n     *\n     * @param  {function} callback the predicate used on each item.\n     * @return {Collection} A collection without the rejected elements.\n     * @example\n     * const collection = new Collection([\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]).reject(stark => stark.age < 14);\n     * console.log(collection.all()); // [{ name: 'Jon Snow', age: 14 }]\n     */\n    reject(callback) {\n        const items = [];\n        this.items.forEach((item) => {\n            if (! callback(item)) {\n                items.push(item);\n            }\n        });\n\n        return new Collection(items);\n    }\n\n    /**\n     * Removes an item from the collection.\n     *\n     * @param  {*} item the item to be searched and removed, first occurance will be removed.\n     * @return {boolean} True if the element was removed, false otherwise.\n     * @example\n     * const collection = new Collection(['john', 'arya', 'bran']);\n     * collection.remove('john');\n     * console.log(collection.all()); // ['arya', 'bran']\n     */\n    remove(item) {\n        const index = this.find(item);\n        if (~index) {\n            this.items.splice(index, 1);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Reverses the collection order.\n     *\n     * @return {Collection} A new collection with the reversed order.\n     * @example\n     * const collection = new Collection(['one', 'two', 'three']).reverse();\n     * console.log(collection.all()); // ['three', 'two', 'one']\n     */\n    reverse() {\n        return new Collection(this.items.reverse());\n    }\n\n    /**\n     * Skips a specified number of elements.\n     *\n     * @param  {number} count the number of items to be skipped.\n     * @return {Collection} A collection without the skipped items.\n     * @example\n     * const collection = new Collection(['John', 'Arya', 'Bran', 'Sansa']).skip(2);\n     * console.log(collection.all()); // ['Bran', 'Sansa']\n     */\n    skip(count) {\n        return this.slice(count);\n    }\n\n    /**\n     * Slices the collection starting from a specific index and ending at a specified index.\n     *\n     * @param  {number} start The zero-based starting index.\n     * @param  {number} [end=length] The zero-based ending index.\n     * @return {Collection} A collection with the sliced items.\n     * @example <caption>start and end are specified</caption>\n     * const collection = new Collection([0, 1, 2, 3, 4, 5, 6]).slice(2, 4);\n     * console.log(collection.all()); // [2, 3]\n     *\n     * @example <caption>only start is specified</caption>\n     * const collection = new Collection([0, 1, 2, 3, 4, 5, 6]).slice(2);\n     * console.log(collection.all()); // [2, 3, 4, 5, 6]\n     */\n    slice(start, end = this.items.length) {\n        return new Collection(this.items.slice(start, end));\n    }\n\n    /**\n     * Sorts the elements of a collection and returns a new sorted collection.\n     * note that it doesn't change the orignal collection and it creates a\n     * shallow copy.\n     *\n     * @param  {function} [compare=undefined] the compare function.\n     * @return {Collection} A new collection with the sorted items.\n     *\n     * @example\n     * const collection = new Collection([5, 3, 4, 1, 2]);\n     * const sorted = collection.sort();\n     * // original collection is intact.\n     * console.log(collection.all()); // [5, 3, 4, 1, 2]\n     * console.log(sorted.all()); // [1, 2, 3, 4, 5]\n     */\n    sort(compare = undefined) {\n        return new Collection(this.items.slice().sort(compare));\n    }\n\n    /**\n     * Sorts the collection by key value comaprison, given that the items are objects.\n     * It creates a shallow copy and retains the order of the orignal collection.\n     *\n     * @param  {string} property the key or the property to be compared.\n     * @param  {string} [order='asc'] The sorting order.\n     * use 'asc' for ascending or 'desc' for descending, case insensitive.\n     * @return {Collection} A new Collection with the sorted items.\n     *\n     * @example\n     * const collection = new Collection([\n     *     { name: 'Jon Snow', age: 14 },\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Bran Stark', age: 7 },\n     * ]).sortBy('age');\n     *\n     * console.log(collection.pluck('name').all()); // ['Brand Stark', 'Arya Stark', 'Jon Snow']\n     */\n    sortBy(property, order = 'asc') {\n        const isAscending = order.toLowerCase() === 'asc';\n\n        return this.sort((a, b) => {\n            if (a[property] > b[property]) {\n                return isAscending ? 1 : -1;\n            }\n\n            if (a[property] < b[property]) {\n                return isAscending ? -1 : 1;\n            }\n\n            return 0;\n        });\n    }\n\n    /**\n     * {stringifies the collection using JSON.stringify API.\n     *\n     * @return {string} The stringified value.\n     * @example\n     * const collection = new Collection([1, 2, 3]);\n     * console.log(collection.stringify()); // \"[1,2,3]\"\n     */\n    stringify() {\n        return JSON.stringify(this.items);\n    }\n\n    /**\n     * Sums the values of the array, or the properties, or the result of the callback.\n     *\n     * @param  {undefined|string|function} [property=null] the property to be summed.\n     * @return {*} The sum of values used in the summation.\n     * @example <caption>Summing elements</caption>\n     * const collection = new Collection([1, 2, 3]);\n     * console.log(collection.sum()); // 6\n     *\n     * @example <caption>Summing a property</caption>\n     * const collection = new Collection([\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]);\n     * console.log(collection.sum('age')); // 30\n     *\n     * @example <caption>Summing using a callback</caption>\n     * const collection = new Collection([\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]);\n     * console.log(collection.sum(i => i.age + 1)); // 33\n     */\n    sum(property = null) {\n        if (typeof property === 'string') {\n            return this.reduce((previous, current) =>\n                previous + current[property]\n            , 0);\n        }\n\n        if (typeof property === 'function') {\n            return this.reduce((previous, current) =>\n                previous + property(current)\n            , 0);\n        }\n\n        return this.reduce((previous, current) =>\n            previous + current\n        , 0);\n    }\n\n    /**\n     * Gets a new collection with the number of specified items from the begining or the end.\n     *\n     * @param  {number} count the number of items to take. Takes from end if negative.\n     * @return {Collection} A collection with the taken items.\n     * @example <caption>From the beginning</caption>\n     * const collection = new Collection([1, 2, 3, 4, 5]).take(3);\n     * console.log(collection.all()); // [1, 2, 3]\n     *\n     * @example <caption>From the end</caption>\n     * const collection = new Collection([1, 2, 3, 4, 5]).take(-3);\n     * console.log(collection.all()); // [5, 4 ,3]\n     */\n    take(count) {\n        if (! count) {\n            return new Collection([]);\n        }\n\n        if (count < 0) {\n            return new Collection(this.items.reverse()).take(-count);\n        }\n\n        return new Collection(this.items.slice(0, count));\n    }\n\n    /**\n     * Registers a new method on the collection prototype for future use.\n     * The closure gets the collection object passed as the first parameter then\n     * other parameters gets passed after.\n     *\n     * @param  {string} name The name of the macro function.\n     * @param  {function} callback A closure containing the behavior of the macro.\n     * @return {*} returns your callback result.\n     *\n     * @example\n     * Collection.macro('addToMembers', (collection, n) => collection.map(item => item + n));\n     * const col2 = new Collection([1, 2, 3, 4]).addToMembers(3);\n     * console.log(col2.all()); // [4, 5, 6, 7]\n     */\n    static macro(name, callback) {\n        if (Collection.prototype[name] !== undefined) {\n            throw new Error('Collection.macro(): This macro name is already defined.');\n        }\n\n        Collection.prototype[name] = function collectionMacroWrapper(...args) {\n            const collection = this;\n\n            return callback(collection, ...args);\n        };\n    }\n\n    /**\n     * Remove duplicate values from the collection.\n     *\n     * @param {function|string} [callback=null] The predicate that returns a value\n     * which will be checked for uniqueness, or a string that has the name of the property.\n     * @return {Collection} A collection containing ue values.\n     * @example <caption>No Arguments</caption>\n     * const unique = new Collection([2, 1, 2, 3, 3, 4, 5, 1, 2]).unique();\n     * console.log(unique); // [2, 1, 3, 4, 5]\n     * @example <caption>Property Name</caption>\n     * const students = new Collection([\n     * \t\t{ name: 'Rick', grade: 'A'},\n     * \t\t{ name: 'Mick', grade: 'B'},\n     * \t\t{ name: 'Richard', grade: 'A'},\n     * ]);\n     * // Students with unique grades.\n     * students.unique('grade'); // [{ name: 'Rick', grade: 'A'}, { name: 'Mick', grade: 'B'}]\n     * @example <caption>With Callback</caption>\n     * const students = new Collection([\n     * \t\t{ name: 'Rick', grade: 'A'},\n     * \t\t{ name: 'Mick', grade: 'B'},\n     * \t\t{ name: 'Richard', grade: 'A'},\n     * ]);\n     * // Students with unique grades.\n     * students.unique(s => s.grade); // [{ name: 'Rick', grade: 'A'}, { name: 'Mick', grade: 'B'}]\n     */\n    unique(callback = null) {\n        if (typeof callback === 'string') {\n            return this.unique(item => item[callback]);\n        }\n\n        if (callback) {\n            const mappedCollection = new Collection();\n\n            return this.reduce((collection, item) => {\n                const mappedItem = callback(item);\n                if (! mappedCollection.has(mappedItem)) {\n                    collection.add(item);\n                    mappedCollection.add(mappedItem);\n                }\n\n                return collection;\n            }, new Collection);\n        }\n\n        return this.reduce((collection, item) => {\n            if (! collection.has(item)) {\n                collection.add(item);\n            }\n\n            return collection;\n        }, new Collection);\n    }\n\n    /**\n     * Gets the values without preserving the keys.\n     *\n     * @return {Collection} A Collection containing the values.\n     * @example\n     * const collection = new Collection({\n     *     1: 2,\n     *     2: 3,\n     *     4: 5\n     * }).values();\n     *\n     * console.log(collection.all()); / /[2, 3, 5]\n     */\n    values() {\n        return this.keys().map(key => this.items[key]);\n    }\n\n    /**\n     * Filters the collection using a callback or equality comparison to a property in each item.\n     *\n     * @param  {function|string} callback The callback to be used to filter the collection.\n     * @param  {*} [value=null] The value to be compared.\n     * @return {Collection} A collection with the filtered items.\n     * @example <caption>Using a property name</caption>\n     * const collection = new Collection([\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]).where('age', 14);\n     * console.log(collection.all()); // [{ name: 'Jon Snow', age: 14 }]\n     *\n     * @example <caption>Using a callback</caption>\n     * const collection = new Collection([\n     *     { name: 'Arya Stark', age: 9 },\n     *     { name: 'Bran Stark', age: 7 },\n     *     { name: 'Jon Snow', age: 14 }\n     * ]).where(stark => stark.age === 14);\n     * console.log(collection.all()); // [{ name: 'Jon Snow', age: 14 }]\n     */\n    where(callback, value = null) {\n        if (typeof(callback) === 'string') {\n            return this.filter(item => item[callback] === value);\n        }\n\n        return this.filter(callback);\n    }\n\n    /**\n     * Pairs each item in the collection with another array item in the same index.\n     *\n     * @param  {Array|Collection} array the array to be paired with.\n     * @return {Collection} A collection with the paired items.\n     * @example\n     * const array = ['a', 'b', 'c']; // or a collection.\n     * const collection = new Collection([1, 2, 3]).zip(array);\n     * console.log(collection.all()); // [[1, 'a'], [2, 'b'], [3, 'c']]\n     */\n    zip(array) {\n        if (array instanceof Collection) {\n            return this.map((item, index) => [item, array.get(index)]);\n        }\n\n        return this.map((item, index) => [item, array[index]]);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/collection.js\n **/"],"sourceRoot":""}